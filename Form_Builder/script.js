// Deep Cloning Utilities
class DeepClone {
    static clone(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof Array) return obj.map(item => DeepClone.clone(item));
        if (typeof obj === 'object') {
            const cloned = {};
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    cloned[key] = DeepClone.clone(obj[key]);
                }
            }
            return cloned;
        }
        return obj;
    }
}

// Object Mutation Tracker
class MutationTracker {
    constructor() {
        this.mutations = [];
        this.listeners = [];
    }

    track(action, target, details = {}) {
        const mutation = {
            id: Date.now() + Math.random(),
            timestamp: new Date().toISOString(),
            action,
            target,
            details: DeepClone.clone(details)
        };
        
        this.mutations.push(mutation);
        this.notifyListeners(mutation);
        return mutation;
    }

    addListener(callback) {
        this.listeners.push(callback);
    }

    notifyListeners(mutation) {
        this.listeners.forEach(callback => callback(mutation));
    }

    clear() {
        this.mutations = [];
        this.notifyListeners({ action: 'clear', timestamp: new Date().toISOString() });
    }

    getMutations() {
        return DeepClone.clone(this.mutations);
    }
}

// JSON Schema Generator
class SchemaGenerator {
    static generateSchema(formConfig) {
        const schema = {
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            title: formConfig.title || "Generated Form",
            description: formConfig.description || "Form generated by Dynamic Form Builder",
            properties: {},
            required: []
        };

        formConfig.components.forEach(component => {
            const property = this.componentToSchemaProperty(component);
            schema.properties[component.name] = property;
            
            if (component.required) {
                schema.required.push(component.name);
            }
        });

        return schema;
    }

    static componentToSchemaProperty(component) {
        const baseProperty = {
            title: component.label,
            description: component.description || ""
        };

        switch (component.type) {
            case 'text':
            case 'email':
                return {
                    ...baseProperty,
                    type: "string",
                    format: component.type === 'email' ? 'email' : undefined,
                    minLength: component.minLength || undefined,
                    maxLength: component.maxLength || undefined,
                    pattern: component.pattern || undefined
                };
            
            case 'number':
                return {
                    ...baseProperty,
                    type: "number",
                    minimum: component.min || undefined,
                    maximum: component.max || undefined
                };
            
            case 'select':
            case 'radio':
                return {
                    ...baseProperty,
                    type: "string",
                    enum: component.options?.map(opt => opt.value) || []
                };
            
            case 'checkbox':
                return {
                    ...baseProperty,
                    type: "boolean"
                };
            
            case 'textarea':
                return {
                    ...baseProperty,
                    type: "string",
                    minLength: component.minLength || undefined,
                    maxLength: component.maxLength || undefined
                };
            
            case 'date':
                return {
                    ...baseProperty,
                    type: "string",
                    format: "date"
                };
            
            case 'file':
                return {
                    ...baseProperty,
                    type: "string",
                    format: "binary"
                };
            
            default:
                return {
                    ...baseProperty,
                    type: "string"
                };
        }
    }
}

// Form Component Base Class
class FormComponent {
    constructor(type, config = {}) {
        this.id = config.id || `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        this.type = type;
        this.name = config.name || this.id;
        this.label = config.label || this.getDefaultLabel();
        this.required = config.required || false;
        this.placeholder = config.placeholder || '';
        this.description = config.description || '';
        this.value = config.value || this.getDefaultValue();
        this.validation = config.validation || {};
        this.cssClass = config.cssClass || '';
        this.attributes = config.attributes || {};
    }

    getDefaultLabel() {
        return this.type.charAt(0).toUpperCase() + this.type.slice(1) + ' Field';
    }

    getDefaultValue() {
        switch (this.type) {
            case 'checkbox': return false;
            case 'number': return 0;
            default: return '';
        }
    }

    render() {
        return `<div class="form-component" data-id="${this.id}" data-type="${this.type}">
            ${this.renderControls()}
            ${this.renderField()}
        </div>`;
    }

    renderControls() {
        return `<div class="component-controls">
            <button class="control-btn edit" data-action="edit">‚úèÔ∏è</button>
            <button class="control-btn delete" data-action="delete">üóëÔ∏è</button>
        </div>`;
    }

    renderField() {
        return `<div class="form-group">
            <label for="${this.id}">${this.label}${this.required ? ' *' : ''}</label>
            ${this.renderInput()}
            ${this.description ? `<small class="form-text">${this.description}</small>` : ''}
        </div>`;
    }

    renderInput() {
        return `<input type="${this.type}" id="${this.id}" name="${this.name}" 
                placeholder="${this.placeholder}" ${this.required ? 'required' : ''} 
                class="${this.cssClass}" value="${this.value}">`;
    }

    getConfig() {
        return {
            id: this.id,
            type: this.type,
            name: this.name,
            label: this.label,
            required: this.required,
            placeholder: this.placeholder,
            description: this.description,
            value: this.value,
            validation: this.validation,
            cssClass: this.cssClass,
            attributes: this.attributes
        };
    }

    updateConfig(newConfig) {
        Object.assign(this, newConfig);
    }
}

// Specialized Components
class SelectComponent extends FormComponent {
    constructor(config = {}) {
        super('select', config);
        this.options = config.options || [
            { label: 'Option 1', value: 'option1' },
            { label: 'Option 2', value: 'option2' }
        ];
    }

    renderInput() {
        const optionsHtml = this.options.map(option => 
            `<option value="${option.value}" ${option.value === this.value ? 'selected' : ''}>${option.label}</option>`
        ).join('');
        
        return `<select id="${this.id}" name="${this.name}" ${this.required ? 'required' : ''} class="${this.cssClass}">
            ${optionsHtml}
        </select>`;
    }

    getConfig() {
        return {
            ...super.getConfig(),
            options: this.options
        };
    }
}

class RadioComponent extends FormComponent {
    constructor(config = {}) {
        super('radio', config);
        this.options = config.options || [
            { label: 'Option 1', value: 'option1' },
            { label: 'Option 2', value: 'option2' }
        ];
    }

    renderInput() {
        const optionsHtml = this.options.map((option, index) => 
            `<div class="radio-item">
                <input type="radio" id="${this.id}_${index}" name="${this.name}" 
                       value="${option.value}" ${option.value === this.value ? 'checked' : ''}>
                <label for="${this.id}_${index}">${option.label}</label>
            </div>`
        ).join('');
        
        return `<div class="radio-group">${optionsHtml}</div>`;
    }

    getConfig() {
        return {
            ...super.getConfig(),
            options: this.options
        };
    }
}

class TextareaComponent extends FormComponent {
    constructor(config = {}) {
        super('textarea', config);
        this.rows = config.rows || 4;
    }

    renderInput() {
        return `<textarea id="${this.id}" name="${this.name}" placeholder="${this.placeholder}" 
                ${this.required ? 'required' : ''} class="${this.cssClass}" rows="${this.rows}">${this.value}</textarea>`;
    }

    getConfig() {
        return {
            ...super.getConfig(),
            rows: this.rows
        };
    }
}

// Component Factory
class ComponentFactory {
    static create(type, config = {}) {
        switch (type) {
            case 'select': return new SelectComponent(config);
            case 'radio': return new RadioComponent(config);
            case 'textarea': return new TextareaComponent(config);
            default: return new FormComponent(type, config);
        }
    }
}

// Config-driven UI Renderer
class UIRenderer {
    constructor(container) {
        this.container = container;
        this.virtualDOM = [];
    }

    render(components) {
        // Virtual DOM diffing simulation
        const newVirtualDOM = components.map(component => ({
            id: component.id,
            type: component.type,
            html: component.render(),
            component: component
        }));

        this.diff(this.virtualDOM, newVirtualDOM);
        this.virtualDOM = newVirtualDOM;
    }

    diff(oldVDOM, newVDOM) {
        // Simple diffing algorithm
        const container = this.container;
        
        // Remove deleted components
        const oldIds = oldVDOM.map(item => item.id);
        const newIds = newVDOM.map(item => item.id);
        
        oldIds.forEach(id => {
            if (!newIds.includes(id)) {
                const element = container.querySelector(`[data-id="${id}"]`);
                if (element) element.remove();
            }
        });

        // Add or update components
        newVDOM.forEach((newItem, index) => {
            const existingElement = container.querySelector(`[data-id="${newItem.id}"]`);
            
            if (existingElement) {
                // Update existing element
                if (existingElement.outerHTML !== newItem.html) {
                    existingElement.outerHTML = newItem.html;
                }
            } else {
                // Add new element
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = newItem.html;
                const newElement = tempDiv.firstElementChild;
                
                if (index === 0) {
                    container.insertBefore(newElement, container.firstChild);
                } else {
                    const prevElement = container.querySelector(`[data-id="${newVDOM[index - 1].id}"]`);
                    if (prevElement && prevElement.nextSibling) {
                        container.insertBefore(newElement, prevElement.nextSibling);
                    } else {
                        container.appendChild(newElement);
                    }
                }
            }
        });
    }
}

// Main Form Builder Application
class FormBuilder {
    constructor() {
        this.components = [];
        this.selectedComponent = null;
        this.formConfig = {
            title: 'Dynamic Form',
            description: 'Generated form',
            components: []
        };
        this.mutationTracker = new MutationTracker();
        this.renderer = null;
        
        this.init();
    }

    init() {
        this.setupRenderer();
        this.setupEventListeners();
        this.setupMutationTracking();
        this.updateOutputs();
    }

    setupRenderer() {
        const canvas = document.querySelector('.drop-zone');
        this.renderer = new UIRenderer(canvas);
    }

    setupEventListeners() {
        // Drag and drop
        this.setupDragAndDrop();
        
        // Component selection
        document.addEventListener('click', (e) => {
            if (e.target.closest('.form-component')) {
                this.selectComponent(e.target.closest('.form-component'));
            }
        });

        // Control buttons
        document.addEventListener('click', (e) => {
            if (e.target.matches('.control-btn[data-action="delete"]')) {
                this.deleteComponent(e.target.closest('.form-component'));
            }
        });

        // Template buttons
        document.querySelectorAll('.template-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                this.loadTemplate(e.target.dataset.template);
            });
        });

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                this.switchTab(e.target.dataset.tab);
            });
        });

        // Clear form
        document.getElementById('clearForm').addEventListener('click', () => {
            this.clearForm();
        });

        // Export schema
        document.getElementById('exportSchema').addEventListener('click', () => {
            this.exportSchema();
        });
    }

    setupDragAndDrop() {
        // Make components draggable
        document.querySelectorAll('.component-item').forEach(item => {
            item.draggable = true;
            item.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.dataset.type);
                e.target.classList.add('dragging');
            });
            
            item.addEventListener('dragend', (e) => {
                e.target.classList.remove('dragging');
            });
        });

        // Drop zone
        const dropZone = document.querySelector('.drop-zone');
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', (e) => {
            if (!dropZone.contains(e.relatedTarget)) {
                dropZone.classList.remove('drag-over');
            }
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            
            const componentType = e.dataTransfer.getData('text/plain');
            this.addComponent(componentType);
        });
    }

    setupMutationTracking() {
        this.mutationTracker.addListener((mutation) => {
            this.updateMutationsLog(mutation);
        });
    }

    addComponent(type) {
        const component = ComponentFactory.create(type);
        this.components.push(component);
        
        this.mutationTracker.track('ADD_COMPONENT', 'FormBuilder', {
            componentId: component.id,
            componentType: type,
            totalComponents: this.components.length
        });

        this.updateFormConfig();
        this.render();
        this.updateOutputs();
    }

    deleteComponent(element) {
        const componentId = element.dataset.id;
        const componentIndex = this.components.findIndex(c => c.id === componentId);
        
        if (componentIndex !== -1) {
            const component = this.components[componentIndex];
            this.components.splice(componentIndex, 1);
            
            this.mutationTracker.track('DELETE_COMPONENT', 'FormBuilder', {
                componentId: componentId,
                componentType: component.type,
                totalComponents: this.components.length
            });

            if (this.selectedComponent?.id === componentId) {
                this.selectedComponent = null;
                this.updatePropertiesPanel();
            }

            this.updateFormConfig();
            this.render();
            this.updateOutputs();
        }
    }

    selectComponent(element) {
        // Remove previous selection
        document.querySelectorAll('.form-component.selected').forEach(el => {
            el.classList.remove('selected');
        });

        // Add selection to clicked component
        element.classList.add('selected');
        
        const componentId = element.dataset.id;
        this.selectedComponent = this.components.find(c => c.id === componentId);
        
        this.mutationTracker.track('SELECT_COMPONENT', 'FormBuilder', {
            componentId: componentId,
            componentType: this.selectedComponent?.type
        });

        this.updatePropertiesPanel();
    }

    updatePropertiesPanel() {
        const propertiesContent = document.getElementById('propertiesContent');
        
        if (!this.selectedComponent) {
            propertiesContent.innerHTML = `
                <div class="no-selection">
                    <span class="icon">üëÜ</span>
                    <p>Select a component to edit properties</p>
                </div>`;
            return;
        }

        const component = this.selectedComponent;
        propertiesContent.innerHTML = `
            <div class="property-group">
                <label>Label</label>
                <input type="text" data-property="label" value="${component.label}">
            </div>
            <div class="property-group">
                <label>Name</label>
                <input type="text" data-property="name" value="${component.name}">
            </div>
            <div class="property-group">
                <label>Placeholder</label>
                <input type="text" data-property="placeholder" value="${component.placeholder}">
            </div>
            <div class="property-group">
                <label>Description</label>
                <textarea data-property="description" rows="2">${component.description}</textarea>
            </div>
            <div class="property-group">
                <label>
                    <input type="checkbox" data-property="required" ${component.required ? 'checked' : ''}>
                    Required Field
                </label>
            </div>
            ${this.renderTypeSpecificProperties(component)}
        `;

        // Add event listeners for property changes
        propertiesContent.querySelectorAll('[data-property]').forEach(input => {
            input.addEventListener('input', (e) => {
                this.updateComponentProperty(e.target.dataset.property, e.target.value, e.target.type === 'checkbox' ? e.target.checked : e.target.value);
            });
        });
    }

    renderTypeSpecificProperties(component) {
        if (component.type === 'select' || component.type === 'radio') {
            const optionsHtml = component.options.map((option, index) => `
                <div class="option-item">
                    <input type="text" placeholder="Label" value="${option.label}" data-option-index="${index}" data-option-property="label">
                    <input type="text" placeholder="Value" value="${option.value}" data-option-index="${index}" data-option-property="value">
                    <button type="button" class="btn btn-small" onclick="this.parentElement.remove()">Remove</button>
                </div>
            `).join('');

            return `
                <div class="property-group">
                    <label>Options</label>
                    <div class="options-list">${optionsHtml}</div>
                    <button type="button" class="btn btn-small" id="addOption">Add Option</button>
                </div>
            `;
        }
        return '';
    }

    updateComponentProperty(property, value, actualValue = null) {
        if (this.selectedComponent) {
            const oldValue = this.selectedComponent[property];
            this.selectedComponent[property] = actualValue !== null ? actualValue : value;
            
            this.mutationTracker.track('UPDATE_PROPERTY', 'Component', {
                componentId: this.selectedComponent.id,
                property: property,
                oldValue: oldValue,
                newValue: this.selectedComponent[property]
            });

            this.updateFormConfig();
            this.render();
            this.updateOutputs();
        }
    }

    updateFormConfig() {
        this.formConfig.components = this.components.map(component => component.getConfig());
        
        this.mutationTracker.track('UPDATE_CONFIG', 'FormBuilder', {
            componentCount: this.components.length,
            configSize: JSON.stringify(this.formConfig).length
        });
    }

    render() {
        this.renderer.render(this.components);
        
        // Update component count
        document.getElementById('componentCount').textContent = this.components.length;
        
        // Show/hide drop placeholder
        const dropPlaceholder = document.querySelector('.drop-placeholder');
        if (dropPlaceholder) {
            dropPlaceholder.style.display = this.components.length > 0 ? 'none' : 'block';
        }
    }

    updateOutputs() {
        // Update JSON Schema
        const schema = SchemaGenerator.generateSchema(this.formConfig);
        document.getElementById('schemaOutput').textContent = JSON.stringify(schema, null, 2);
        
        // Update Form Config
        document.getElementById('configOutput').textContent = JSON.stringify(this.formConfig, null, 2);
        
        // Update Form Data (simulated)
        const formData = {};
        this.components.forEach(component => {
            formData[component.name] = component.value;
        });
        document.getElementById('dataOutput').textContent = JSON.stringify(formData, null, 2);
    }

    updateMutationsLog(mutation) {
        const mutationsOutput = document.getElementById('mutationsOutput');
        
        if (mutation.action === 'clear') {
            mutationsOutput.innerHTML = '<p>Mutations log cleared</p>';
            return;
        }

        const entry = document.createElement('div');
        entry.className = 'mutation-entry';
        entry.innerHTML = `
            <div class="mutation-timestamp">${new Date(mutation.timestamp).toLocaleTimeString()}</div>
            <div class="mutation-action">${mutation.action}</div>
            <div class="mutation-details">${JSON.stringify(mutation.details, null, 2)}</div>
        `;
        
        mutationsOutput.insertBefore(entry, mutationsOutput.firstChild);
        
        // Limit to 50 entries
        while (mutationsOutput.children.length > 50) {
            mutationsOutput.removeChild(mutationsOutput.lastChild);
        }
    }

    switchTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabName);
        });

        // Update tab panes
        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.classList.toggle('active', pane.id === `${tabName}Tab`);
        });
    }

    clearForm() {
        this.components = [];
        this.selectedComponent = null;
        this.updateFormConfig();
        this.render();
        this.updatePropertiesPanel();
        this.updateOutputs();
        
        this.mutationTracker.track('CLEAR_FORM', 'FormBuilder', {
            previousComponentCount: this.components.length
        });
    }

    loadTemplate(templateName) {
        const templates = {
            contact: [
                { type: 'text', label: 'Full Name', name: 'fullName', required: true },
                { type: 'email', label: 'Email Address', name: 'email', required: true },
                { type: 'text', label: 'Phone Number', name: 'phone' },
                { type: 'textarea', label: 'Message', name: 'message', required: true, rows: 4 }
            ],
            survey: [
                { type: 'radio', label: 'How satisfied are you?', name: 'satisfaction', options: [
                    { label: 'Very Satisfied', value: 'very_satisfied' },
                    { label: 'Satisfied', value: 'satisfied' },
                    { label: 'Neutral', value: 'neutral' },
                    { label: 'Dissatisfied', value: 'dissatisfied' }
                ]},
                { type: 'select', label: 'Age Group', name: 'ageGroup', options: [
                    { label: '18-25', value: '18-25' },
                    { label: '26-35', value: '26-35' },
                    { label: '36-45', value: '36-45' },
                    { label: '46+', value: '46+' }
                ]},
                { type: 'textarea', label: 'Additional Comments', name: 'comments' }
            ],
            registration: [
                { type: 'text', label: 'First Name', name: 'firstName', required: true },
                { type: 'text', label: 'Last Name', name: 'lastName', required: true },
                { type: 'email', label: 'Email', name: 'email', required: true },
                { type: 'date', label: 'Date of Birth', name: 'dob' },
                { type: 'checkbox', label: 'I agree to terms and conditions', name: 'terms', required: true }
            ],
            feedback: [
                { type: 'text', label: 'Your Name', name: 'name' },
                { type: 'select', label: 'Rating', name: 'rating', options: [
                    { label: '5 Stars', value: '5' },
                    { label: '4 Stars', value: '4' },
                    { label: '3 Stars', value: '3' },
                    { label: '2 Stars', value: '2' },
                    { label: '1 Star', value: '1' }
                ]},
                { type: 'textarea', label: 'Feedback', name: 'feedback', required: true }
            ]
        };

        const template = templates[templateName];
        if (template) {
            this.clearForm();
            template.forEach(config => {
                const component = ComponentFactory.create(config.type, config);
                this.components.push(component);
            });

            this.mutationTracker.track('LOAD_TEMPLATE', 'FormBuilder', {
                templateName: templateName,
                componentCount: this.components.length
            });

            this.updateFormConfig();
            this.render();
            this.updateOutputs();
        }
    }

    exportSchema() {
        const schema = SchemaGenerator.generateSchema(this.formConfig);
        const blob = new Blob([JSON.stringify(schema, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'form-schema.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.mutationTracker.track('EXPORT_SCHEMA', 'FormBuilder', {
            schemaSize: JSON.stringify(schema).length,
            componentCount: this.components.length
        });
    }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    const formBuilder = new FormBuilder();
    
    // Copy buttons functionality
    document.getElementById('copySchema').addEventListener('click', () => {
        navigator.clipboard.writeText(document.getElementById('schemaOutput').textContent);
    });
    
    document.getElementById('copyConfig').addEventListener('click', () => {
        navigator.clipboard.writeText(document.getElementById('configOutput').textContent);
    });
    
    document.getElementById('copyData').addEventListener('click', () => {
        navigator.clipboard.writeText(document.getElementById('dataOutput').textContent);
    });
    
    document.getElementById('clearMutations').addEventListener('click', () => {
        formBuilder.mutationTracker.clear();
    });
});
